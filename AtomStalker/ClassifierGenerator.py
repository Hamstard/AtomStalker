import sys, cPickle
sys.path.append("D:/Anaconda/envs/python2/Lib/site-packages")
import pywt, copy
from sklearn.ensemble import AdaBoostClassifier
import numpy as np

class ClassificationTrainer(object):
    """Class to train classifiers given labeled samples.
    
    The classifiers are generated by default for Haar wavelets. 
    
    Parameters
    ----------
    
    wavelet : str
        By default set to 'haar' selecting the Haar wavelet for feature calculation.
    
    """
    def __init__(self,wavelet='haar'):
        self.features = None
        self.samples = None
        self.classifier = None
        self.intensities = None
        if wavelet != 'haar':
            allowed_wavelets = pywt.wavelist()
            assert wavelet in allowed_wavelets, "Assertion failed - provided wavelet {} not understood, please chose one of the following: {}".format(wavelet,allowed_wavelets)
        self.wavelet = wavelet
        
    def set_samples(self,samples):
        print("Setting samples...")
        self.samples, self.intensities = [[]]*len(samples), [0]*len(samples)
        for i,sample in enumerate(samples):
            intensity = np.sum(sample)
            self.samples[i] = np.array(sample)/intensity
            self.intensities[i] = intensity
                
    def sample_to_feature_vec(self,sample,intensity):
        
        feature_vec = list(np.ravel(pywt.dwt(sample,self.wavelet)[0])) + [intensity]
        feature_vec = np.array(feature_vec)
        return feature_vec
    
    def get_features(self):
        """Produces the features for classification.
        
        Uses Haar wavelets by default.
        
        """
        nsamples = len(self.samples)
        num_features = len(self.sample_to_feature_vec(self.samples[0],self.intensities[0]))
        self.features = np.zeros((nsamples,num_features))
        
        for i in xrange(nsamples):            
            feature_vec = np.array(list(np.ravel(pywt.dwt(self.samples[i],self.wavelet)[0]))+[self.intensities[i]])
            self.features[i] = self.sample_to_feature_vec(self.samples[i],self.intensities[i])
                
    def set_classifier_and_train(self,classifier,classifications):
        print("setting classifier and training...")
        classifier_shape = copy.deepcopy(classifier)
        self.classifier = classifier_shape.fit(self.features,classifications)
        
    def get_predictions(self,observations):
        nsamples = len(self.samples)
        num_features = len(self.sample_to_feature_vec(observations[0],42.))
        features = np.zeros((nsamples,num_features))
        for i,obs in enumerate(observations):
            intensity = np.sum(obs)
            obs /= intensity
            feature_vec = self.sample_to_feature_vec(obs,intensity)
            features[i] = feature_vec
                    
        return self.classifier.predict(features)
    
    def save_classifier2disk(self,path):
        print '\nWriting classifier to {}...'.format(path)
        with open(path,'w') as f:
            cPickle.dump(self.classifier,f)